# 背包DP合集

[www.acwing.com](https://www.acwing.com/blog/content/7688/)

> 前言：**背包DP** 属于 **线性DP** 中的一种经典模型，围绕 **容量**、**物品**、**体积**、**价值**等关键字展开
> 
> 求解的是一种符合题设要求的 **选择物品** 的 **方案**

## 目录

> **AcWing** 为了防止 **攻击**，把 **HTML禁掉了**，所以目录里的 **锚点** 都失效了

1.  背包DP概述
2.  0-1背包
3.  完全背包
4.  多重背包
    1.  二进制分组优化
    2.  单调队列优化
5.  混合背包
6.  分组背包
7.  有依赖的背包
    1.  子物品体积集合划分
    2.  子物品组合集合划分
8.  背包问题的杂项
    1.  小优化
    2.  输出方案
    3.  求方案数
    4.  求最优方案总数

## 1\. 背包DP概述

背包问题的常见描述：

*   有 N 件物品和一个总容量为 V 的背包
    
*   第 i 件物品的 **体积** 是 v i ，**价值** 是 w i
    
*   找出一种选择物品的 **方案**，使得选择的物品的总体积不超过 V ，且 **总价值** 最大
    

然后针对于不同的 **背包类型**，对于选择物品的方式有着各式各样的 **限制性条件**，接下来一一列举

## 2\. 01背包

**限制性条件：** 每件物品 **只能选择一次**

**01背包** 是所有 **背包模型** 中，最为简单的一种模型。正如他的名字一样，不选(0)或是选(1)的背包模型。

常用的 **01背包** DP分析如下：

*   **状态表示 f i , j —集合：** 考虑前 **i** 个物品，且当前已使用体积不超过 **j** 的方案
    
*   **状态表示 f i , j —属性：** 该方案的价值为最大值 max
    
*   **状态转移 f i , j ：** f i , j \= max ( f i − 1 , j , f i − 1 , j − v i \+ w i )
    

常用的 **01背包** 优化方式是 **空间优化**

因为对于 **i** 阶段的状态 f i , j 来说，他的 **状态转移** 只会依赖 **i-1** 层的状态 f i − 1 , j 和 f i − 1 , j − v i

因此我们可以把空间**优化到一维**，直接用 f j 表示 **处理当前物品时，总体积不超过 j 的方案**

优化后的 **状态转移方程** 如下：-

f j \= m a x ( f j , f j − v i \+ w i )

核心代码如下：

    for (int i = 1; i <= n; ++ i)
        for (int j = m; j >= v[i]; -- j)//注意迭代的顺序，i层状态要用i-1层的旧状态更新
            f[j] = max(f[j], f[j - v[i]] + w[i]);


**01背包** 经典题目汇总：(顺序按难度递增)

1.  [AcWing 2. 01背包问题](https://www.acwing.com/problem/content/2/)
    
2.  [AcWing 423. 采药【01背包DP模型+朴素优化】](https://www.acwing.com/solution/content/52491/)
    
3.  [AcWing 1024. 装箱问题【01背包DP模型】](https://www.acwing.com/solution/content/52608/)
    
4.  [AcWing 426. 开心的金明【01背包DP模型】](https://www.acwing.com/solution/content/54006/)
    
5.  [AcWing 8. 二维费用的背包问题【二维费用01背包问题】](https://www.acwing.com/solution/content/53753/)
    
6.  [AcWing 1022. 宠物小精灵之收服【二维费用01背包问题】](https://www.acwing.com/solution/content/52741/)
    
7.  [AcWing 1020. 潜水员【01背包问题+二维费用’不少于’问题】](https://www.acwing.com/solution/content/53848/)
    
8.  [AcWing 734. 能量石【01背包 + 贪心（邻项交换）】](https://www.acwing.com/solution/content/54699/)

## 3\. 完全背包

**限制性条件：** 每件物品 **可以使用无限多次**

**完全背包** 也是 **背包模型** 中的经典模型，也是仅次于 **01背包**的最简单的一种 **背包模型**

因为每件物品可以使用 **无限多次** 而得名

常用的 **完全背包** DP分析如下：

*   **状态表示 f i , j —集合：** 考虑前 **i** 个物品，且当前已使用体积不超过 **j** 的方案
    
*   **状态表示 f i , j —属性：** 该方案的价值为最大值 max
    
*   **状态转移 f i , j ：** f i , j \= max k \= 0 \+ ∞ ( f i − 1 , j − k × v i \+ k × w i )
    

上述状态转移方程直接计算的话，最坏情况下的时间复杂度是 O ( N × V 2 )

通过观察可以发现，状态 f i , j 的更新依赖 f i − 1 , j 和 f i , j − v i \+ w i

也可以通过如下递推式获得上述结论：-

f ( i , j ) \= max ( f ( i − 1 , j ) , f ( i − 1 , j − v i ) \+ w i , ⋯ , f ( i − 1 , j − s v i ) \+ s w i ) f ( i , j − v i ) \= max ( f ( i − 1 , j − v i ) , ⋯ , f ( i − 1 , j − s v i ) \+ ( s − 1 ) w i )

因此 **状态转移 f i , j** 可以优化为： f i , j \= max ( f i − 1 , j , f i , j − v i \+ w i )

这样，**时间复杂度** 就是 O ( N × V ) 了

空间上，优化思路和 **01背包** 类似，可以优化掉一维的空间

优化后的 **状态转移方程** 如下：-

f j \= max ( f j , f j − v i \+ w i )

**核心代码** 如下：

```cpp
for (int i = 1; i <= n; ++ i)
    for (int j = v[i]; j <= m; ++ j)
        f[j] = max(f[j], f[j - v[i]] + w[i]);
```


**完全背包** 经典题目汇总：(顺序按难度递增)

1.  [AcWing 3. 完全背包问题](https://www.acwing.com/problem/content/3/)
    
2.  [AcWing 1023. 买书【完全背包求解方案数+朴素优化】](https://www.acwing.com/solution/content/52967/)
    
3.  [AcWing 1021. 货币系统【完全背包求解方案数】](https://www.acwing.com/solution/content/53119/)
    
4.  [AcWing 532. 货币系统【完全背包求解最大无关向量组个数】](https://www.acwing.com/solution/content/53198/)
    

## 4\. 多重背包

**限制性条件：** 每件物品 **只能被使用有限多次**

**多重背包** 在原来 **完全背包** 中额外限制了每个物品的 **最多使用次数** 是 s i

因此原来完全背包的 **优化无效**

常用的 **多重背包** DP分析如下：

*   **状态表示 f i , j —集合：** 考虑前 **i** 个物品，且当前已使用体积不超过 **j** 的方案
    
*   **状态表示 f i , j —属性：** 该方案的价值为最大值 max
    
*   **状态转移 f i , j ：** f i , j \= max k \= 0 s i ( f i − 1 , j − k × v i \+ k × w i )
    

时间复杂度： O ( N × V × ∑ s i )

### 二进制分组优化

把 **多重背包** 转化为 **多个01背包** 来求解

O ( N × V ) 是背包的最快时间复杂度，因此我们可以优化的就是 O ( ∑ s i )

常识告诉我们，任意的 **十进制数** 可以通过进制转换变成 **二进制比特串**

我们可以把当前的物品数 s i 拆分成 **能且仅能** 表示 \[ 0 , s i \] 所有数的几个 **01物品**

这样，从前往后做一遍 **01背包DP** 便可以求解本题

具体就是令 A i , j  ( j ∈ \[ 0 , ⌊ log 2 ⁡ ( s i \+ 1 ) ⌋ − 1 \] ) 分别表示由 2 j 个物品 i 捆绑而成的大物品

特殊地，若 s i \+ 1 不是 2 的整数次幂，则需要最后添加由 s i − 2 ⌊ log 2 ⁡ ( s i \+ 1 ) ⌋ − 1 个物品 i 捆绑而成的大物品补足

举几个简单的例子：

*   6 = 1 + 2 + 3
*   8 = 1 + 2 + 4 + 1
*   18 = 1 + 2 + 4 + 8 + 3
*   31 = 1 + 2 + 4 + 8 + 16

二进制分组优化代码

```cpp
for (int i = 1; i <= n; ++i)
{
    int a, b, s;
    scanf("%d%d%d", &a, &b, &s);
    int k = 1;
    while (k <= s)  //二进制拆分
    {
        ++cnt;
        v[cnt] = k * a;
        w[cnt] = k * b;
        s -= k;
        k *= 2;
    }
    if (s)  //补足剩余部分
    {
        ++cnt;
        v[cnt] = s * a;
        w[cnt] = s * b;
    }
}
```


### 单调队列优化

这个我在之前的某篇题解里详细写过

具体可以看 **[AcWing 6. 多重背包问题 III【单调队列优化+图示】](https://www.acwing.com/solution/content/53507/)**

**多重背包** 经典题目汇总：(顺序按难度递增)

1.  [AcWing 4.多重背包问题 I](https://www.acwing.com/problem/content/4/)
    
2.  [AcWing 1019. 庆功会【多重背包朴素版】](https://www.acwing.com/solution/content/53584/)
    
3.  [AcWing 5.多重背包问题 II](https://www.acwing.com/problem/content/5/)
    
4.  [AcWing 6. 多重背包问题 III【单调队列优化+图示】](https://www.acwing.com/solution/content/53507/)
    

## 5\. 混合背包

混合背包就是对 **01背包**、**完全背包**、**多重背包** 三者的结合

对于第 i 种物品

1.  可能最多只能使用 1 次(01背包)
2.  最多只能使用 s i 次(多重背包)
3.  可以无限次使用(完全背包)

对于已经学会前三种背包的读者来说，这个就很简单了，对于不同种类，处理不同的状态转移即可

核心代码如下：

```cpp
for (物品i)
{
    if (是 01背包)
        套用01背包代码;
    else if (是 完全背包)
        套用完全背包代码;
    else if (是 多重背包)
        套用多重背包代码
}
```


**混合背包** 经典题目汇总：(顺序按难度递增)

1.  [AcWing 7. 混合背包问题【混合背包DP模型】](https://www.acwing.com/solution/content/53633/)

## 6\. 分组背包

**限制性条件：** 第 i 个物品是一个物品组，里面有 s i 个物品，但是在物品组 i 中最多只能选一个物品

**01背包** 是相对于全局，当前物品最多选一件物品；而 **分组背包** 是相对于物品组 i ，当前物品最多选一件

因此我们直接在每个物品组中套用一遍 **01背包** 的 **状态转移** 即可

核心代码如下：

```cpp
for (int i = 1; i <= n; ++ i)
    for (int j = m; j >= 0; -- j)
        for (int k = 1; k <= s[i]; ++ k)
            if (v[i][k] <= j)
                f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);
```

**分组背包** 经典题目汇总：(顺序按难度递增)

1.  [AcWing 9. 分组背包问题](https://www.acwing.com/problem/content/9/)

## 7\. 有依赖的背包

**限制性条件：** 选第 i 件物品，就必须选择第 j 件物品，保证不会循环引用

一般我们称呼不依赖于别的物品的物品为 **主件**，依赖于某主件的物品称为 **附件**

对于包含一个 **主件** 和若干个 **附件** 的结合由以下可能性：

1.  仅选择**主件**
    
2.  选择主件再选择**一**个附件
    
3.  选择主件再选择**两**个附件
    
    ............
    
4.  选择主件再选择**全部**的附件
    

对于 **有依赖的背包问题** 我们一般采用 **树形DP** 的方式来求解

关于**集合的划分**，针对于 **附件的数量** 有两种方式

**附件组合过多**，则**划分体积**，**时间复杂度**为 O ( N × V × V )

具体参照 [AcWing 10. 有依赖的背包问题【有依赖背包DP+子物品体积集合划分】](https://www.acwing.com/solution/content/54139/)

**附件组合不多**，**体积较大**时，则对附件组合进行 **分组背包DP**，**时间复杂度**为 O ( N × V × 2 k )

具体参照 [AcWing 487. 金明的预算方案【有依赖背包DP+分组背包集合划分】](https://www.acwing.com/solution/content/54723/)

## 8\. 背包问题的杂项

### 小优化

根据贪心原理，当 **费用相同** 时，只需**保留价值最高**的

当 **价值一定** 时，只需 **保留费用最低** 的

当有两件物品 𝑖, 𝑗 且 𝑖 的价值大于 𝑗 的价值并且 𝑖 的费用小于 𝑗 的费用是，只需保留 𝑗

* * *

### 输出方案

输出方案就是输出由 **初始状态** 抵达 **目标状态** 的路径

具体分析都写在如下题解里（一个展示了迭代的写法，一个展示了递归的写法）

1.  [AcWing 12. 背包问题求具体方案【01背包 + 背包DP输出方案】](https://www.acwing.com/solution/content/54306/)
    
2.  [AcWing 1013. 机器分配【分组背包+背包DP输出方案—拓扑图分析】](https://www.acwing.com/solution/content/53963/)
    

* * *

### 求方案数

对于给定物品费用、背包容量以及其他关系，求恰好装满背包容量时，方案的个数

只需对 **状态转移** 中，**求最大值** 的步骤改为 **求和** 即可-

f j \= ∑ ( f j , f j − v i )

初始状态： f 0 \= 1

目标状态： f V

**求方案数** 经典题目汇总：

1.  [AcWing 278. 数字组合【01背包求解方案数】](https://www.acwing.com/solution/content/52801/)
    
2.  [AcWing 1021. 货币系统【完全背包求解方案数】](https://www.acwing.com/solution/content/53119/)
    

* * *

### 求最优方案总数

详见 [AcWing 11. 背包问题求方案数【背包DP求最优方案总数】](https://www.acwing.com/solution/content/54273/)

* * *

## 参考资料

*   [背包问题九讲 - 崔添翼](https://github.com/tianyicui/pack)
*   [OI Wiki\_背包DP](https://oi-wiki.org/dp/knapsack/)

[跳转到 Cubox 查看](https://cubox.pro/my/card?id=ff808081895ecfe40189a99ae4285327)